package com.practice.leetcode.interview;

import org.junit.jupiter.api.Test;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                         RECURSION & DYNAMIC PROGRAMMING                                          â•‘
 * â•‘                    Äá»‡ quy cÆ¡ báº£n + DP patterns phá»• biáº¿n                                          â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ğŸ“Š RECURSION VS DP:
 * â€¢ Recursion: Chia bÃ i toÃ¡n thÃ nh bÃ i toÃ¡n con, cÃ³ thá»ƒ cÃ³ overlapping
 * â€¢ Memoization: Cache káº¿t quáº£ Ä‘á»ƒ trÃ¡nh tÃ­nh láº¡i (Top-down)
 * â€¢ Tabulation: XÃ¢y dá»±ng tá»« base case lÃªn (Bottom-up)
 * 
 * ğŸ“Š PHá»” BIáº¾N NHáº¤T TRONG PHá»NG Váº¤N:
 * â€¢ Climbing Stairs, Fibonacci
 * â€¢ Coin Change
 * â€¢ Longest Common Subsequence
 * â€¢ 0/1 Knapsack pattern
 */
public class P05_RecursionDP {

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 70 - CLIMBING STAIRS â­â­
    //                       https://leetcode.com/problems/climbing-stairs/
    //                              (DP entry-level classic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ CÃ³ n báº­c thang. Má»—i bÆ°á»›c cÃ³ thá»ƒ leo 1 hoáº·c 2 báº­c.                                           â”‚
     * â”‚ Äáº¿m sá»‘ cÃ¡ch leo lÃªn Ä‘á»‰nh.                                                                   â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ n = 2 â†’ 2 cÃ¡ch: (1+1), (2)                                                                  â”‚
     * â”‚ n = 3 â†’ 3 cÃ¡ch: (1+1+1), (1+2), (2+1)                                                       â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY: Fibonacci!                                                                          â”‚
     * â”‚ f(n) = f(n-1) + f(n-2)                                                                      â”‚
     * â”‚ Äáº¿n báº­c n cÃ³ thá»ƒ tá»« n-1 (1 bÆ°á»›c) hoáº·c n-2 (2 bÆ°á»›c)                                          â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N) thá»i gian, O(1) khÃ´ng gian                                                â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int climbStairs(int n) {
        if (n <= 2) return n;
        
        int prev2 = 1; // f(1)
        int prev1 = 2; // f(2)
        
        for (int i = 3; i <= n; i++) {
            int current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 322 - COIN CHANGE â­â­â­
    //                         https://leetcode.com/problems/coin-change/
    //                              (Classic DP - ráº¥t hay há»i)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ Cho cÃ¡c má»‡nh giÃ¡ coin. TÃ¬m sá»‘ coin ÃT NHáº¤T Ä‘á»ƒ táº¡o amount.                                   â”‚
     * â”‚ Tráº£ vá» -1 náº¿u khÃ´ng thá»ƒ.                                                                    â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ coins = [1, 2, 5], amount = 11 â†’ 3 (5 + 5 + 1)                                              â”‚
     * â”‚ coins = [2], amount = 3 â†’ -1                                                                â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY:                                                                                     â”‚
     * â”‚ dp[i] = sá»‘ coin tá»‘i thiá»ƒu Ä‘á»ƒ táº¡o amount i                                                   â”‚
     * â”‚ dp[i] = min(dp[i - coin] + 1) vá»›i má»i coin                                                  â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(amount * coins) thá»i gian, O(amount) khÃ´ng gian                              â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1); // GiÃ¡ trá»‹ lá»›n = impossible
        dp[0] = 0;
        
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (coin <= i && dp[i - coin] != amount + 1) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        
        return dp[amount] > amount ? -1 : dp[amount];
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                    LC 1143 - LONGEST COMMON SUBSEQUENCE â­â­â­
    //              https://leetcode.com/problems/longest-common-subsequence/
    //                              (2D DP classic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ TÃ¬m Ä‘á»™ dÃ i subsequence chung dÃ i nháº¥t cá»§a 2 string.                                         â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ text1 = "abcde", text2 = "ace" â†’ 3 ("ace")                                                  â”‚
     * â”‚ text1 = "abc", text2 = "abc" â†’ 3                                                            â”‚
     * â”‚ text1 = "abc", text2 = "def" â†’ 0                                                            â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY:                                                                                     â”‚
     * â”‚ dp[i][j] = LCS cá»§a text1[0..i-1] vÃ  text2[0..j-1]                                           â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Náº¿u text1[i-1] == text2[j-1]:                                                               â”‚
     * â”‚   dp[i][j] = dp[i-1][j-1] + 1                                                               â”‚
     * â”‚ NgÆ°á»£c láº¡i:                                                                                  â”‚
     * â”‚   dp[i][j] = max(dp[i-1][j], dp[i][j-1])                                                    â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(m * n) thá»i gian, O(m * n) khÃ´ng gian                                        â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 198 - HOUSE ROBBER â­â­
    //                         https://leetcode.com/problems/house-robber/
    //                              (1D DP classic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ KhÃ´ng Ä‘Æ°á»£c cÆ°á»›p 2 nhÃ  liá»n ká». TÃ¬m sá»‘ tiá»n tá»‘i Ä‘a cÃ³ thá»ƒ cÆ°á»›p.                              â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ [1, 2, 3, 1] â†’ 4 (cÆ°á»›p nhÃ  1 vÃ  3)                                                          â”‚
     * â”‚ [2, 7, 9, 3, 1] â†’ 12 (cÆ°á»›p nhÃ  1, 3, 5)                                                     â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY:                                                                                     â”‚
     * â”‚ dp[i] = max tiá»n khi xÃ©t Ä‘áº¿n nhÃ  i                                                          â”‚
     * â”‚ dp[i] = max(dp[i-1], dp[i-2] + nums[i])                                                     â”‚
     * â”‚ (khÃ´ng cÆ°á»›p nhÃ  i, hoáº·c cÆ°á»›p nhÃ  i + max tá»« i-2)                                            â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N) thá»i gian, O(1) khÃ´ng gian                                                â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        
        int prev2 = nums[0];               // dp[i-2]
        int prev1 = Math.max(nums[0], nums[1]); // dp[i-1]
        
        for (int i = 2; i < nums.length; i++) {
            int current = Math.max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 300 - LONGEST INCREASING SUBSEQUENCE â­â­
    //              https://leetcode.com/problems/longest-increasing-subsequence/
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ TÃ¬m Ä‘á»™ dÃ i subsequence tÄƒng dáº§n dÃ i nháº¥t.                                                   â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ [10, 9, 2, 5, 3, 7, 101, 18] â†’ 4 ([2, 3, 7, 101])                                           â”‚
     * â”‚                                                                                             â”‚
     * â”‚ CÃCH 1: DP - O(NÂ²)                                                                          â”‚
     * â”‚ dp[i] = LIS káº¿t thÃºc táº¡i i                                                                  â”‚
     * â”‚ dp[i] = max(dp[j] + 1) vá»›i má»i j < i vÃ  nums[j] < nums[i]                                   â”‚
     * â”‚                                                                                             â”‚
     * â”‚ CÃCH 2: Binary Search - O(N log N)                                                          â”‚
     * â”‚ DÃ¹ng máº£ng tails[i] = pháº§n tá»­ cuá»‘i nhá» nháº¥t cá»§a LIS Ä‘á»™ dÃ i i                                 â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    // CÃ¡ch 1: DP O(NÂ²)
    public int lengthOfLISDP(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        
        return maxLen;
    }
    
    // CÃ¡ch 2: Binary Search O(N log N) - RECOMMENDED cho phá»ng váº¥n
    public int lengthOfLIS(int[] nums) {
        List<Integer> tails = new ArrayList<>();
        
        for (int num : nums) {
            int pos = Collections.binarySearch(tails, num);
            if (pos < 0) pos = -(pos + 1);
            
            if (pos == tails.size()) {
                tails.add(num);
            } else {
                tails.set(pos, num);
            }
        }
        
        return tails.size();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 62 - UNIQUE PATHS â­â­
    //                          https://leetcode.com/problems/unique-paths/
    //                              (2D Grid DP basic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ Äi tá»« gÃ³c trÃªn trÃ¡i Ä‘áº¿n gÃ³c dÆ°á»›i pháº£i. Chá»‰ Ä‘Æ°á»£c Ä‘i pháº£i hoáº·c xuá»‘ng.                         â”‚
     * â”‚ Äáº¿m sá»‘ Ä‘Æ°á»ng Ä‘i.                                                                            â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ m = 3, n = 7 â†’ 28                                                                           â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY:                                                                                     â”‚
     * â”‚ dp[i][j] = sá»‘ cÃ¡ch Ä‘áº¿n Ã´ (i, j)                                                             â”‚
     * â”‚ dp[i][j] = dp[i-1][j] + dp[i][j-1]                                                          â”‚
     * â”‚ (tá»« trÃªn xuá»‘ng + tá»« trÃ¡i sang)                                                              â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(m*n) thá»i gian, O(n) khÃ´ng gian (tá»‘i Æ°u)                                     â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        
        return dp[n - 1];
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 46 - PERMUTATIONS â­â­
    //                          https://leetcode.com/problems/permutations/
    //                              (Backtracking classic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ Sinh táº¥t cáº£ hoÃ¡n vá»‹ cá»§a máº£ng distinct.                                                      â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ [1, 2, 3] â†’ [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]                               â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY: Backtracking                                                                        â”‚
     * â”‚ â€¢ Chá»n 1 pháº§n tá»­ chÆ°a dÃ¹ng                                                                  â”‚
     * â”‚ â€¢ ThÃªm vÃ o path                                                                             â”‚
     * â”‚ â€¢ Äá»‡ quy                                                                                    â”‚
     * â”‚ â€¢ Backtrack (xÃ³a pháº§n tá»­ vá»«a thÃªm)                                                          â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N * N!) thá»i gian                                                            â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrackPermute(nums, new ArrayList<>(), new boolean[nums.length], result);
        return result;
    }
    
    private void backtrackPermute(int[] nums, List<Integer> path, 
                                   boolean[] used, List<List<Integer>> result) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            
            path.add(nums[i]);
            used[i] = true;
            
            backtrackPermute(nums, path, used, result);
            
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                              LC 78 - SUBSETS â­â­
    //                            https://leetcode.com/problems/subsets/
    //                              (Backtracking classic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ Äá»€ BÃ€I:                                                                                     â”‚
     * â”‚ Sinh táº¥t cáº£ táº­p con cá»§a máº£ng distinct.                                                      â”‚
     * â”‚                                                                                             â”‚
     * â”‚ VÃ Dá»¤:                                                                                      â”‚
     * â”‚ [1, 2, 3] â†’ [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]                               â”‚
     * â”‚                                                                                             â”‚
     * â”‚ TÆ¯ DUY: Backtracking                                                                        â”‚
     * â”‚ â€¢ Vá»›i má»—i pháº§n tá»­: chá»n hoáº·c khÃ´ng chá»n                                                     â”‚
     * â”‚ â€¢ Má»—i node trong tree Ä‘á»u lÃ  1 subset há»£p lá»‡                                                â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N * 2^N) thá»i gian                                                           â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrackSubsets(nums, 0, new ArrayList<>(), result);
        return result;
    }
    
    private void backtrackSubsets(int[] nums, int start, 
                                   List<Integer> path, List<List<Integer>> result) {
        result.add(new ArrayList<>(path));
        
        for (int i = start; i < nums.length; i++) {
            path.add(nums[i]);
            backtrackSubsets(nums, i + 1, path, result);
            path.remove(path.size() - 1);
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                         TESTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    @Test
    void testClimbStairs() {
        assertEquals(2, climbStairs(2));
        assertEquals(3, climbStairs(3));
        assertEquals(5, climbStairs(4));
    }
    
    @Test
    void testCoinChange() {
        assertEquals(3, coinChange(new int[]{1, 2, 5}, 11));
        assertEquals(-1, coinChange(new int[]{2}, 3));
    }
    
    @Test
    void testLongestCommonSubsequence() {
        assertEquals(3, longestCommonSubsequence("abcde", "ace"));
        assertEquals(0, longestCommonSubsequence("abc", "def"));
    }
    
    @Test
    void testRob() {
        assertEquals(4, rob(new int[]{1, 2, 3, 1}));
        assertEquals(12, rob(new int[]{2, 7, 9, 3, 1}));
    }
    
    @Test
    void testLengthOfLIS() {
        assertEquals(4, lengthOfLIS(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));
    }
    
    @Test
    void testUniquePaths() {
        assertEquals(28, uniquePaths(3, 7));
        assertEquals(3, uniquePaths(3, 2));
    }
    
    @Test
    void testPermute() {
        List<List<Integer>> result = permute(new int[]{1, 2, 3});
        assertEquals(6, result.size()); // 3! = 6
    }
    
    @Test
    void testSubsets() {
        List<List<Integer>> result = subsets(new int[]{1, 2, 3});
        assertEquals(8, result.size()); // 2^3 = 8
    }
}
