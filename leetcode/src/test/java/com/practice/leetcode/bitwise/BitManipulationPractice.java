package com.practice.leetcode.bitwise;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘          BIT MANIPULATION PRACTICE - EASY TO MEDIUM                       â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘ Tá»« dá»… Ä‘áº¿n khÃ³, giáº£i thÃ­ch chi tiáº¿t cho ngÆ°á»i má»›i                          â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * ROADMAP (theo thá»© tá»± nÃªn lÃ m):
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * 1. LC 136 - Single Number (Easy)           - XOR cÆ¡ báº£n
 * 2. LC 191 - Number of 1 Bits (Easy)        - n & (n-1) pattern
 * 3. LC 231 - Power of Two (Easy)            - n & (n-1) pattern
 * 4. LC 268 - Missing Number (Easy)          - XOR vá»›i index
 * 5. LC 190 - Reverse Bits (Easy)            - Get/Set bit
 * 6. LC 338 - Counting Bits (Easy)           - DP + bit
 * 7. LC 461 - Hamming Distance (Easy)        - XOR + count
 * 8. LC 78  - Subsets (Medium)               - Bitmask enumeration
 * 9. LC 260 - Single Number III (Medium)     - Advanced XOR
 */
public class BitManipulationPractice {

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #1. LC 136 - SINGLE NUMBER (Easy) â­ Báº®T Äáº¦U Tá»ª ÄÃ‚Y
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Máº£ng cÃ³ cÃ¡c sá»‘ xuáº¥t hiá»‡n 2 láº§n, CHá»ˆ 1 sá»‘ xuáº¥t hiá»‡n 1 láº§n.                   â”‚
   * â”‚ TÃ¬m sá»‘ Ä‘Ã³. YÃªu cáº§u: O(n) time, O(1) space.                                  â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: [4, 1, 2, 1, 2] â†’ Output: 4                                          â”‚
   * â”‚                                                                             â”‚
   * â”‚ KEY INSIGHT:                                                                â”‚
   * â”‚ â€¢ XOR cÃ³ tÃ­nh cháº¥t: a ^ a = 0 (sá»‘ giá»‘ng nhau XOR = 0)                       â”‚
   * â”‚ â€¢ XOR cÃ³ tÃ­nh cháº¥t: a ^ 0 = a (XOR vá»›i 0 giá»¯ nguyÃªn)                        â”‚
   * â”‚ â€¢ XOR cÃ³ tÃ­nh giao hoÃ¡n: a ^ b ^ a = a ^ a ^ b = 0 ^ b = b                  â”‚
   * â”‚                                                                             â”‚
   * â”‚ â†’ XOR táº¥t cáº£ cÃ¡c sá»‘: cÃ¡c cáº·p triá»‡t tiÃªu, cÃ²n láº¡i sá»‘ duy nháº¥t!               â”‚
   * â”‚                                                                             â”‚
   * â”‚ MINH Há»ŒA:                                                                   â”‚
   * â”‚ [4, 1, 2, 1, 2]                                                             â”‚
   * â”‚   4 ^ 1 ^ 2 ^ 1 ^ 2                                                         â”‚
   * â”‚ = 4 ^ (1 ^ 1) ^ (2 ^ 2)   (nhÃ³m láº¡i)                                        â”‚
   * â”‚ = 4 ^ 0 ^ 0                                                                 â”‚
   * â”‚ = 4                                                                         â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
      result ^= num;  // XOR táº¥t cáº£
    }
    return result;
  }

  @Test
  void testSingleNumber() {
    assertEquals(1, singleNumber(new int[]{2, 2, 1}));
    assertEquals(4, singleNumber(new int[]{4, 1, 2, 1, 2}));
    assertEquals(1, singleNumber(new int[]{1}));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #2. LC 191 - NUMBER OF 1 BITS (Easy)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Äáº¿m sá»‘ bit 1 trong biá»ƒu diá»…n binary cá»§a n (Hamming Weight)                  â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: 11 = 1011 â†’ Output: 3 (cÃ³ 3 bit 1)                                   â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH 1: Check tá»«ng bit (32 láº§n)                                             â”‚
   * â”‚ while (n != 0) { if ((n & 1) == 1) count++; n >>>= 1; }                     â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH 2: n & (n-1) trick â­ (tá»‘i Æ°u hÆ¡n)                                     â”‚
   * â”‚ n & (n-1) XÃ“A bit 1 tháº¥p nháº¥t!                                              â”‚
   * â”‚                                                                             â”‚
   * â”‚ Táº I SAO n & (n-1) xÃ³a bit 1 tháº¥p nháº¥t?                                      â”‚
   * â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
   * â”‚ n     = 1010 (cÃ³ bit 1 á»Ÿ vá»‹ trÃ­ 1 lÃ  tháº¥p nháº¥t)                             â”‚
   * â”‚ n-1   = 1001 (trá»« 1: bit 1 tháº¥p nháº¥t â†’ 0, cÃ¡c bit 0 bÃªn pháº£i â†’ 1)           â”‚
   * â”‚ n&n-1 = 1000 (AND: bit 1 tháº¥p nháº¥t bá»‹ xÃ³a!)                                 â”‚
   * â”‚                                                                             â”‚
   * â”‚ n     = 1100                                                                â”‚
   * â”‚ n-1   = 1011                                                                â”‚
   * â”‚ n&n-1 = 1000                                                                â”‚
   * â”‚                                                                             â”‚
   * â”‚ â†’ Äáº¿m sá»‘ láº§n thá»±c hiá»‡n n & (n-1) Ä‘áº¿n khi n = 0 = sá»‘ bit 1                   â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
      n &= (n - 1);  // XÃ³a bit 1 tháº¥p nháº¥t
      count++;       // Äáº¿m
    }
    return count;
  }

  @Test
  void testHammingWeight() {
    assertEquals(3, hammingWeight(0b1011));       // 11
    assertEquals(1, hammingWeight(0b10000000));   // 128
    assertEquals(31, hammingWeight(Integer.MAX_VALUE)); // 2^31 - 1
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #3. LC 231 - POWER OF TWO (Easy)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Kiá»ƒm tra n cÃ³ pháº£i lÅ©y thá»«a cá»§a 2 khÃ´ng (1, 2, 4, 8, 16, ...)               â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ KEY INSIGHT:                                                                â”‚
   * â”‚ Power of 2 chá»‰ cÃ³ ÄÃšNG 1 bit = 1:                                           â”‚
   * â”‚   1 = 0001                                                                  â”‚
   * â”‚   2 = 0010                                                                  â”‚
   * â”‚   4 = 0100                                                                  â”‚
   * â”‚   8 = 1000                                                                  â”‚
   * â”‚                                                                             â”‚
   * â”‚ n & (n-1) xÃ³a bit 1 tháº¥p nháº¥t:                                              â”‚
   * â”‚ â€¢ Náº¿u n lÃ  power of 2 (chá»‰ cÃ³ 1 bit 1) â†’ n & (n-1) = 0                      â”‚
   * â”‚ â€¢ Náº¿u n khÃ´ng pháº£i power of 2 (>1 bit 1) â†’ n & (n-1) â‰  0                    â”‚
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤:                                                                      â”‚
   * â”‚   8 = 1000, 8-1 = 0111, 8 & 7 = 0 â†’ âœ“ Power of 2                            â”‚
   * â”‚   6 = 0110, 6-1 = 0101, 6 & 5 = 0100 â‰  0 â†’ âœ— KhÃ´ng pháº£i                     â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public boolean isPowerOfTwo(int n) {
    // n > 0: loáº¡i sá»‘ Ã¢m vÃ  0
    // n & (n-1) == 0: chá»‰ cÃ³ 1 bit = 1
    return n > 0 && (n & (n - 1)) == 0;
  }

  @Test
  void testIsPowerOfTwo() {
    assertTrue(isPowerOfTwo(1));    // 2^0
    assertTrue(isPowerOfTwo(16));   // 2^4
    assertTrue(isPowerOfTwo(1024)); // 2^10
    assertFalse(isPowerOfTwo(3));
    assertFalse(isPowerOfTwo(0));
    assertFalse(isPowerOfTwo(-2));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #4. LC 268 - MISSING NUMBER (Easy)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Máº£ng chá»©a n sá»‘ tá»« 0 Ä‘áº¿n n, thiáº¿u 1 sá»‘. TÃ¬m sá»‘ Ä‘Ã³.                           â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: [3, 0, 1] (n=3, dÃ£y 0-3) â†’ Output: 2 (thiáº¿u sá»‘ 2)                    â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH GIáº¢I:                                                                  â”‚
   * â”‚ â€¢ XOR táº¥t cáº£ cÃ¡c sá»‘ tá»« 0 Ä‘áº¿n n                                              â”‚
   * â”‚ â€¢ XOR vá»›i táº¥t cáº£ cÃ¡c sá»‘ trong máº£ng                                          â”‚
   * â”‚ â€¢ CÃ¡c sá»‘ trÃ¹ng nhau triá»‡t tiÃªu, cÃ²n láº¡i sá»‘ thiáº¿u!                           â”‚
   * â”‚                                                                             â”‚
   * â”‚ MINH Há»ŒA: [3, 0, 1] (n = 3)                                                 â”‚
   * â”‚                                                                             â”‚
   * â”‚ XOR indices: 0 ^ 1 ^ 2 ^ 3 (cÃ¡c index tá»« 0 Ä‘áº¿n n)                           â”‚
   * â”‚ XOR values:  3 ^ 0 ^ 1     (cÃ¡c giÃ¡ trá»‹ trong máº£ng)                         â”‚
   * â”‚                                                                             â”‚
   * â”‚ Káº¿t há»£p: 0 ^ 1 ^ 2 ^ 3 ^ 3 ^ 0 ^ 1                                          â”‚
   * â”‚        = (0^0) ^ (1^1) ^ (3^3) ^ 2                                          â”‚
   * â”‚        = 0 ^ 0 ^ 0 ^ 2                                                      â”‚
   * â”‚        = 2 â† Sá»‘ thiáº¿u!                                                      â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int missingNumber(int[] nums) {
    int n = nums.length;
    int xor = n;  // Báº¯t Ä‘áº§u vá»›i n (vÃ¬ index chá»‰ tá»« 0 Ä‘áº¿n n-1)

    for (int i = 0; i < n; i++) {
      xor ^= i;        // XOR index
      xor ^= nums[i];  // XOR value
    }

    return xor;
  }

  @Test
  void testMissingNumber() {
    assertEquals(2, missingNumber(new int[]{3, 0, 1}));
    assertEquals(2, missingNumber(new int[]{0, 1}));
    assertEquals(8, missingNumber(new int[]{9, 6, 4, 2, 3, 5, 7, 0, 1}));
    assertEquals(0, missingNumber(new int[]{1}));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #5. LC 190 - REVERSE BITS (Easy)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Äáº£o ngÆ°á»£c thá»© tá»± 32 bits cá»§a sá»‘ n                                           â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤:                                                                      â”‚
   * â”‚ n = 00000010100101000001111010011100                                        â”‚
   * â”‚   â†’ 00111001011110000010100101000000                                        â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH GIáº¢I: Duyá»‡t 32 bits, láº¥y tá»«ng bit vÃ  Ä‘áº·t vÃ o vá»‹ trÃ­ Ä‘á»‘i xá»©ng           â”‚
   * â”‚                                                                             â”‚
   * â”‚ THUáº¬T TOÃN:                                                                 â”‚
   * â”‚ for i = 0 to 31:                                                            â”‚
   * â”‚   1. Láº¥y bit thá»© i cá»§a n:     bit = (n >> i) & 1                            â”‚
   * â”‚   2. Äáº·t vÃ o vá»‹ trÃ­ 31-i:     result |= (bit << (31 - i))                   â”‚
   * â”‚                                                                             â”‚
   * â”‚ MINH Há»ŒA vá»›i 4 bits (Ä‘Æ¡n giáº£n hÆ¡n):                                         â”‚
   * â”‚ n = 1011 (Ä‘áº£o thÃ nh 1101)                                                   â”‚
   * â”‚                                                                             â”‚
   * â”‚ i=0: bit = 1, Ä‘áº·t vÃ o pos 3 â†’ result = 1000                                 â”‚
   * â”‚ i=1: bit = 1, Ä‘áº·t vÃ o pos 2 â†’ result = 1100                                 â”‚
   * â”‚ i=2: bit = 0, Ä‘áº·t vÃ o pos 1 â†’ result = 1100 (khÃ´ng Ä‘á»•i)                     â”‚
   * â”‚ i=3: bit = 1, Ä‘áº·t vÃ o pos 0 â†’ result = 1101                                 â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int reverseBits(int n) {
    int result = 0;
    for (int i = 0; i < 32; i++) {
      // BÆ°á»›c 1: Láº¥y bit thá»© i cá»§a n
      int bit = (n >> i) & 1;

      // BÆ°á»›c 2: Äáº·t bit Ä‘Ã³ vÃ o vá»‹ trÃ­ (31 - i) trong result
      result |= (bit << (31 - i));
    }
    return result;
  }

  @Test
  void testReverseBits() {
    assertEquals(964176192, reverseBits(43261596));
    assertEquals(0, reverseBits(0));
    // 1 á»Ÿ bit 0 â†’ Ä‘áº£o â†’ 1 á»Ÿ bit 31
    assertEquals(Integer.MIN_VALUE, reverseBits(1));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #6. LC 338 - COUNTING BITS (Easy)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Vá»›i má»—i sá»‘ tá»« 0 Ä‘áº¿n n, Ä‘áº¿m sá»‘ bit 1. Tráº£ vá» máº£ng káº¿t quáº£.                   â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: n = 5 â†’ [0, 1, 1, 2, 1, 2]                                           â”‚
   * â”‚   0 = 0000 â†’ 0 bit 1                                                        â”‚
   * â”‚   1 = 0001 â†’ 1 bit 1                                                        â”‚
   * â”‚   2 = 0010 â†’ 1 bit 1                                                        â”‚
   * â”‚   3 = 0011 â†’ 2 bit 1                                                        â”‚
   * â”‚   4 = 0100 â†’ 1 bit 1                                                        â”‚
   * â”‚   5 = 0101 â†’ 2 bit 1                                                        â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH 1: DÃ¹ng hammingWeight cho tá»«ng sá»‘ - O(n * 32)                          â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH 2: DP vá»›i n & (n-1) - O(n) â­                                           â”‚
   * â”‚ dp[i] = dp[i & (i-1)] + 1                                                   â”‚
   * â”‚                                                                             â”‚
   * â”‚ Giáº£i thÃ­ch: i & (i-1) xÃ³a bit 1 tháº¥p nháº¥t                                   â”‚
   * â”‚ â†’ Sá»‘ bit 1 cá»§a i = sá»‘ bit 1 cá»§a (i vá»›i bit 1 tháº¥p nháº¥t bá»‹ xÃ³a) + 1          â”‚
   * â”‚                                                                             â”‚
   * â”‚ VD: i = 5 = 101                                                             â”‚
   * â”‚     i & (i-1) = 5 & 4 = 101 & 100 = 100 = 4                                 â”‚
   * â”‚     dp[5] = dp[4] + 1 = 1 + 1 = 2 âœ“                                         â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int[] countBits(int n) {
    int[] dp = new int[n + 1];
    // dp[0] = 0 (sá»‘ 0 cÃ³ 0 bit 1)

    for (int i = 1; i <= n; i++) {
      // i & (i-1) xÃ³a bit 1 tháº¥p nháº¥t
      // Káº¿t quáº£ lÃ  sá»‘ Ä‘Ã£ tÃ­nh trÆ°á»›c Ä‘Ã³ + 1
      dp[i] = dp[i & (i - 1)] + 1;
    }

    return dp;
  }

  @Test
  void testCountBits() {
    assertArrayEquals(new int[]{0, 1, 1}, countBits(2));
    assertArrayEquals(new int[]{0, 1, 1, 2, 1, 2}, countBits(5));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #7. LC 461 - HAMMING DISTANCE (Easy)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ TÃ­nh Hamming Distance giá»¯a 2 sá»‘ = sá»‘ bit khÃ¡c nhau                          â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: x = 1 (0001), y = 4 (0100) â†’ Output: 2                               â”‚
   * â”‚   0001                                                                      â”‚
   * â”‚   0100                                                                      â”‚
   * â”‚   â”€â”€â”€â”€                                                                      â”‚
   * â”‚   bit 0 khÃ¡c (0 vs 1)                                                       â”‚
   * â”‚   bit 2 khÃ¡c (1 vs 0)                                                       â”‚
   * â”‚   â†’ Hamming Distance = 2                                                    â”‚
   * â”‚                                                                             â”‚
   * â”‚ CÃCH GIáº¢I:                                                                  â”‚
   * â”‚ 1. XOR 2 sá»‘: bit khÃ¡c nhau â†’ 1, giá»‘ng nhau â†’ 0                              â”‚
   * â”‚ 2. Äáº¿m sá»‘ bit 1 trong káº¿t quáº£ XOR                                           â”‚
   * â”‚                                                                             â”‚
   * â”‚ VD: 1 ^ 4 = 0001 ^ 0100 = 0101 â†’ 2 bit 1 â†’ Distance = 2                     â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int hammingDistance(int x, int y) {
    int xor = x ^ y;  // Bit khÃ¡c nhau = 1
    return hammingWeight(xor);  // Äáº¿m sá»‘ bit 1
  }

  @Test
  void testHammingDistance() {
    assertEquals(2, hammingDistance(1, 4));
    assertEquals(0, hammingDistance(5, 5));
    assertEquals(1, hammingDistance(3, 1));  // 11 vs 01
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #8. LC 78 - SUBSETS (Medium) â­ QUAN TRá»ŒNG
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Cho máº£ng cÃ¡c sá»‘ unique, tráº£ vá» táº¥t cáº£ subsets (power set)                   â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: [1, 2, 3] â†’ [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]        â”‚
   * â”‚                                                                             â”‚
   * â”‚ KEY INSIGHT: DÃ¹ng bitmask Ä‘á»ƒ biá»ƒu diá»…n subset                               â”‚
   * â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
   * â”‚ n pháº§n tá»­ â†’ 2^n subsets                                                     â”‚
   * â”‚ Má»—i sá»‘ tá»« 0 Ä‘áº¿n 2^n - 1 Ä‘áº¡i diá»‡n cho 1 subset                               â”‚
   * â”‚ Bit thá»© i = 1 â†’ bao gá»“m pháº§n tá»­ thá»© i                                       â”‚
   * â”‚                                                                             â”‚
   * â”‚ VD vá»›i [1, 2, 3]:                                                           â”‚
   * â”‚   mask = 0 = 000 â†’ []           (khÃ´ng chá»n gÃ¬)                             â”‚
   * â”‚   mask = 1 = 001 â†’ [1]          (chá»n pháº§n tá»­ 0)                            â”‚
   * â”‚   mask = 2 = 010 â†’ [2]          (chá»n pháº§n tá»­ 1)                            â”‚
   * â”‚   mask = 3 = 011 â†’ [1, 2]       (chá»n pháº§n tá»­ 0 vÃ  1)                       â”‚
   * â”‚   mask = 4 = 100 â†’ [3]          (chá»n pháº§n tá»­ 2)                            â”‚
   * â”‚   mask = 5 = 101 â†’ [1, 3]       (chá»n pháº§n tá»­ 0 vÃ  2)                       â”‚
   * â”‚   mask = 6 = 110 â†’ [2, 3]       (chá»n pháº§n tá»­ 1 vÃ  2)                       â”‚
   * â”‚   mask = 7 = 111 â†’ [1, 2, 3]    (chá»n táº¥t cáº£)                               â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public java.util.List<java.util.List<Integer>> subsets(int[] nums) {
    java.util.List<java.util.List<Integer>> result = new java.util.ArrayList<>();
    int n = nums.length;
    int totalSubsets = 1 << n;  // 2^n

    // Duyá»‡t tá»« 0 Ä‘áº¿n 2^n - 1
    for (int mask = 0; mask < totalSubsets; mask++) {
      java.util.List<Integer> subset = new java.util.ArrayList<>();

      // Check tá»«ng bit cá»§a mask
      for (int i = 0; i < n; i++) {
        // Náº¿u bit thá»© i = 1 â†’ thÃªm pháº§n tá»­ thá»© i
        if ((mask & (1 << i)) != 0) {
          subset.add(nums[i]);
        }
      }

      result.add(subset);
    }

    return result;
  }

  @Test
  void testSubsets() {
    java.util.List<java.util.List<Integer>> result = subsets(new int[]{1, 2, 3});
    assertEquals(8, result.size());  // 2^3 = 8 subsets
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // #9. LC 260 - SINGLE NUMBER III (Medium) â­ ADVANCED
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ Máº£ng cÃ³ cÃ¡c sá»‘ xuáº¥t hiá»‡n 2 láº§n, CHá»ˆ 2 sá»‘ xuáº¥t hiá»‡n 1 láº§n.                   â”‚
   * â”‚ TÃ¬m 2 sá»‘ Ä‘Ã³.                                                                â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ VÃ Dá»¤: [1, 2, 1, 3, 2, 5] â†’ Output: [3, 5]                                  â”‚
   * â”‚                                                                             â”‚
   * â”‚ ğŸ’¡ XOR táº¥t cáº£ cho ra x ^ y, nhÆ°ng lÃ m sao tÃ¡ch x vÃ  y?                      â”‚
   * â”‚                                                                             â”‚
   * â”‚ THUáº¬T TOÃN:                                                                 â”‚
   * â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
   * â”‚ B1: XOR táº¥t cáº£ â†’ xorResult = x ^ y                                          â”‚
   * â”‚     VD: 1^2^1^3^2^5 = 3^5 = 011^101 = 110 = 6                               â”‚
   * â”‚                                                                             â”‚
   * â”‚ B2: TÃ¬m bit khÃ¡c nhau giá»¯a x vÃ  y (báº¥t ká»³ bit 1 nÃ o trong xorResult)        â”‚
   * â”‚     DÃ¹ng: diffBit = xorResult & (-xorResult) = bit 1 tháº¥p nháº¥t              â”‚
   * â”‚     VD: 6 & (-6) = 110 & 010 = 010 = 2 (bit 1 á»Ÿ vá»‹ trÃ­ 1)                   â”‚
   * â”‚                                                                             â”‚
   * â”‚ B3: Chia máº£ng thÃ nh 2 nhÃ³m dá»±a trÃªn diffBit, XOR má»—i nhÃ³m                   â”‚
   * â”‚     - NhÃ³m 1: cÃ¡c sá»‘ cÃ³ diffBit = 0                                         â”‚
   * â”‚     - NhÃ³m 2: cÃ¡c sá»‘ cÃ³ diffBit = 1                                         â”‚
   * â”‚     x vÃ  y cháº¯c cháº¯n á»Ÿ 2 nhÃ³m khÃ¡c nhau (vÃ¬ bit Ä‘Ã³ khÃ¡c nhau)!              â”‚
   * â”‚                                                                             â”‚
   * â”‚ MINH Há»ŒA vá»›i [1, 2, 1, 3, 2, 5], diffBit = 2 (bit 1):                       â”‚
   * â”‚                                                                             â”‚
   * â”‚ NhÃ³m cÃ³ bit 1 = 0: 1(01), 1(01), 5(101) â†’ XOR = 01^01^101 = 101 = 5         â”‚
   * â”‚ NhÃ³m cÃ³ bit 1 = 1: 2(10), 3(11), 2(10) â†’ XOR = 10^11^10 = 11 = 3            â”‚
   * â”‚                                                                             â”‚
   * â”‚ â†’ x = 3, y = 5 âœ“                                                            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int[] singleNumberIII(int[] nums) {
    // B1: XOR táº¥t cáº£ â†’ x ^ y
    int xorResult = 0;
    for (int num : nums) {
      xorResult ^= num;
    }

    // B2: TÃ¬m bit khÃ¡c nhau (bit 1 tháº¥p nháº¥t)
    int diffBit = xorResult & (-xorResult);

    // B3: Chia 2 nhÃ³m vÃ  XOR
    int x = 0, y = 0;
    for (int num : nums) {
      if ((num & diffBit) == 0) {
        x ^= num;  // NhÃ³m cÃ³ diffBit = 0
      } else {
        y ^= num;  // NhÃ³m cÃ³ diffBit = 1
      }
    }

    return new int[]{x, y};
  }

  @Test
  void testSingleNumberIII() {
    int[] result = singleNumberIII(new int[]{1, 2, 1, 3, 2, 5});
    java.util.Arrays.sort(result);
    assertArrayEquals(new int[]{3, 5}, result);

    result = singleNumberIII(new int[]{0, 1});
    java.util.Arrays.sort(result);
    assertArrayEquals(new int[]{0, 1}, result);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BONUS: LC 371 - SUM OF TWO INTEGERS (Medium)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ Äá»€ BÃ€I:                                                                     â”‚
   * â”‚ TÃ­nh a + b mÃ  KHÃ”NG dÃ¹ng + hoáº·c -                                           â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚                                                                             â”‚
   * â”‚ KEY INSIGHT: MÃ´ phá»ng phÃ©p cá»™ng binary                                      â”‚
   * â”‚                                                                             â”‚
   * â”‚ Khi cá»™ng 2 bit:                                                             â”‚
   * â”‚   0 + 0 = 0, carry = 0                                                      â”‚
   * â”‚   0 + 1 = 1, carry = 0                                                      â”‚
   * â”‚   1 + 0 = 1, carry = 0                                                      â”‚
   * â”‚   1 + 1 = 0, carry = 1  â† XOR cho sum, AND cho carry!                       â”‚
   * â”‚                                                                             â”‚
   * â”‚ THUáº¬T TOÃN:                                                                 â”‚
   * â”‚ 1. sum without carry = a XOR b                                              â”‚
   * â”‚ 2. carry = (a AND b) << 1  (shift left vÃ¬ carry sang bit káº¿)                â”‚
   * â”‚ 3. Láº·p láº¡i: a = sum, b = carry, cho Ä‘áº¿n khi carry = 0                       â”‚
   * â”‚                                                                             â”‚
   * â”‚ VD: 5 + 3                                                                   â”‚
   * â”‚   5 = 101, 3 = 011                                                          â”‚
   * â”‚   sum = 101 ^ 011 = 110 = 6                                                 â”‚
   * â”‚   carry = (101 & 011) << 1 = 001 << 1 = 010 = 2                             â”‚
   * â”‚                                                                             â”‚
   * â”‚   Tiáº¿p: a=6, b=2                                                            â”‚
   * â”‚   sum = 110 ^ 010 = 100 = 4                                                 â”‚
   * â”‚   carry = (110 & 010) << 1 = 010 << 1 = 100 = 4                             â”‚
   * â”‚                                                                             â”‚
   * â”‚   Tiáº¿p: a=4, b=4                                                            â”‚
   * â”‚   sum = 100 ^ 100 = 000 = 0                                                 â”‚
   * â”‚   carry = (100 & 100) << 1 = 100 << 1 = 1000 = 8                            â”‚
   * â”‚                                                                             â”‚
   * â”‚   Tiáº¿p: a=0, b=8                                                            â”‚
   * â”‚   sum = 000 ^ 1000 = 1000 = 8                                               â”‚
   * â”‚   carry = 0 â†’ DONE!                                                         â”‚
   * â”‚                                                                             â”‚
   * â”‚   Result = 8 âœ“ (5 + 3 = 8)                                                  â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */
  public int getSum(int a, int b) {
    while (b != 0) {
      int carry = (a & b) << 1;  // Carry cáº§n shift left
      a = a ^ b;                  // Sum without carry
      b = carry;                  // Tiáº¿p tá»¥c vá»›i carry
    }
    return a;
  }

  @Test
  void testGetSum() {
    assertEquals(3, getSum(1, 2));
    assertEquals(5, getSum(2, 3));
    assertEquals(8, getSum(5, 3));
    assertEquals(0, getSum(-1, 1));
  }
}
