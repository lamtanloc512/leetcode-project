package com.practice.leetcode.graph;

import java.util.*;

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘ 3650. Minimum Cost Path with Edge Reversals                               â•‘
 * â•‘ (Chi phÃ­ Ä‘Æ°á»ng Ä‘i tá»‘i thiá»ƒu vá»›i Ä‘áº£o ngÆ°á»£c cáº¡nh)                           â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ Äá»€ BÃ€I                                                                      â”‚
 * â”‚                                                                             â”‚
 * â”‚ â€¢ Cho Ä‘á»“ thá»‹ cÃ³ hÆ°á»›ng, cÃ³ trá»ng sá»‘ vá»›i n Ä‘á»‰nh (0 Ä‘áº¿n n-1)                   â”‚
 * â”‚ â€¢ edges[i] = [u, v, w]: cáº¡nh tá»« u â†’ v vá»›i chi phÃ­ w                         â”‚
 * â”‚ â€¢ Má»—i Ä‘á»‰nh cÃ³ 1 SWITCH, chá»‰ dÃ¹ng Ä‘Æ°á»£c 1 láº§n:                                â”‚
 * â”‚   - Khi Ä‘áº¿n Ä‘á»‰nh u, cÃ³ thá»ƒ Ä‘áº£o ngÆ°á»£c 1 cáº¡nh Äáº¾N u (v â†’ u) thÃ nh (u â†’ v)     â”‚
 * â”‚   - Äi qua cáº¡nh Ä‘áº£o ngÆ°á»£c tá»‘n 2 * w                                         â”‚
 * â”‚ â€¢ TÃ¬m chi phÃ­ nhá» nháº¥t tá»« node 0 Ä‘áº¿n node n-1                               â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PHÃ‚N TÃCH BÃ€I TOÃN
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * ğŸ”‘ INSIGHT CHÃNH:
 *    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *    â”‚ ÄÃ¢y lÃ  bÃ i Dijkstra má»Ÿ rá»™ng vá»›i STATE TRACKING                        â”‚
 *    â”‚                                                                       â”‚
 *    â”‚ State = (node, Ä‘Ã£ dÃ¹ng switch á»Ÿ node nÃ y chÆ°a?)                       â”‚
 *    â”‚                                                                       â”‚
 *    â”‚ Táº¡i má»—i node, ta cÃ³ 2 loáº¡i cáº¡nh ra:                                   â”‚
 *    â”‚ 1. Outgoing edges (u â†’ v): chi phÃ­ w                                  â”‚
 *    â”‚ 2. Incoming edges (v â†’ u) Ä‘áº£o ngÆ°á»£c: chi phÃ­ 2w (náº¿u chÆ°a dÃ¹ng switch)â”‚
 *    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * ğŸ¯ Táº I SAO DÃ™NG DIJKSTRA?
 *    - Äá»“ thá»‹ cÃ³ trá»ng sá»‘ dÆ°Æ¡ng
 *    - Cáº§n tÃ¬m Ä‘Æ°á»ng Ä‘i ngáº¯n nháº¥t
 *    - CÃ³ thá»ƒ ghÃ© thÄƒm 1 node nhiá»u láº§n vá»›i state khÃ¡c nhau
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * THUáº¬T TOÃN: Modified Dijkstra vá»›i State
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * BÆ¯á»šC 1: XÃ¢y dá»±ng 2 adjacency lists
 *         - outEdges[u] = list of (v, w) - cáº¡nh ra tá»« u
 *         - inEdges[u]  = list of (v, w) - cáº¡nh vÃ o u (Ä‘á»ƒ Ä‘áº£o ngÆ°á»£c)
 *
 * BÆ¯á»šC 2: Dijkstra vá»›i state (node, usedSwitch)
 *         - dist[node][0] = chi phÃ­ min khi chÆ°a dÃ¹ng switch á»Ÿ node
 *         - dist[node][1] = chi phÃ­ min khi Ä‘Ã£ dÃ¹ng switch á»Ÿ node
 *
 * BÆ¯á»šC 3: Vá»›i má»—i state (u, switchUsed):
 *         a) Äi theo outEdges: u â†’ v vá»›i chi phÃ­ w
 *         b) Náº¿u chÆ°a dÃ¹ng switch (switchUsed = 0):
 *            CÃ³ thá»ƒ Ä‘áº£o ngÆ°á»£c inEdges: u â†’ v vá»›i chi phÃ­ 2w
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MINH Há»ŒA
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *            w=3
 *   0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 1           KhÃ´ng cÃ³ Ä‘Æ°á»ng trá»±c tiáº¿p tá»« 0 â†’ 2
 *   â†‘            â†“ w=2       NhÆ°ng cÃ³ cáº¡nh 2 â†’ 0 (w=5)
 *   â”‚            â†“
 *   â””â”€â”€â”€â”€ 2 â†â”€â”€â”€â”€â”˜           Táº¡i node 0: Ä‘áº£o ngÆ°á»£c cáº¡nh (2â†’0) thÃ nh (0â†’2)
 *         w=5                Chi phÃ­ = 2 * 5 = 10
 *
 *   ÄÆ°á»ng Ä‘i: 0 --reverse--> 2  vá»›i chi phÃ­ 10
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
public class MinCostPathWithEdgeReversals {

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * SOLUTION 1: Modified Dijkstra vá»›i State Tracking
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * Æ¯U ÄIá»‚M:
     * âœ“ Optimal - luÃ´n tÃ¬m Ä‘Æ°á»ng ngáº¯n nháº¥t
     * âœ“ Xá»­ lÃ½ Ä‘Æ°á»£c má»i trÆ°á»ng há»£p phá»©c táº¡p
     * âœ“ KhÃ´ng cáº§n DP hay recursion vá»›i memoization
     *
     * NHÆ¯á»¢C ÄIá»‚M:
     * âœ— Code dÃ i hÆ¡n BFS Ä‘Æ¡n giáº£n
     * âœ— Cáº§n xÃ¢y dá»±ng 2 adjacency lists
     *
     * TIME:  O((V + E) * log V) - Dijkstra chuáº©n
     * SPACE: O(V + E) - adjacency lists + priority queue
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * Máº¸O Äá»‚ NHá»š: "SWITCH = STATE Má»šI"
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * ğŸ§  Khi tháº¥y "dÃ¹ng Ä‘Æ°á»£c 1 láº§n" â†’ nghÄ© ngay Ä‘áº¿n THÃŠM STATE
     *
     * Pattern: dist[node][usedFeature]
     *
     * TÆ°Æ¡ng tá»± cÃ¡c bÃ i:
     * - 787. Cheapest Flights Within K Stops: dist[node][stopsUsed]
     * - 1293. Shortest Path in Grid with Obstacles: dist[row][col][obstaclesRemoved]
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */
    public int minimumCost(int n, int[][] edges) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BÆ¯á»šC 1: Build 2 adjacency lists
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        List<int[]>[] outEdges = new ArrayList[n]; // Cáº¡nh ra: u â†’ v
        List<int[]>[] inEdges = new ArrayList[n];  // Cáº¡nh vÃ o: v â†’ u (Ä‘á»ƒ Ä‘áº£o ngÆ°á»£c)

        for (int i = 0; i < n; i++) {
            outEdges[i] = new ArrayList<>();
            inEdges[i] = new ArrayList<>();
        }

        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            outEdges[u].add(new int[]{v, w});      // u â†’ v vá»›i cost w
            inEdges[v].add(new int[]{u, w});       // LÆ°u vÃ o v Ä‘á»ƒ biáº¿t cáº¡nh nÃ o Ä‘áº¿n v
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BÆ¯á»šC 2: Initialize distance array
        // dist[node][switchUsed]
        // - switchUsed = 0: chÆ°a dÃ¹ng switch á»Ÿ node nÃ y
        // - switchUsed = 1: Ä‘Ã£ dÃ¹ng switch á»Ÿ node nÃ y
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        long[][] dist = new long[n][2];
        for (long[] row : dist) {
            Arrays.fill(row, Long.MAX_VALUE);
        }
        dist[0][0] = 0; // Báº¯t Ä‘áº§u táº¡i node 0, chÆ°a dÃ¹ng switch

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BÆ¯á»šC 3: Dijkstra vá»›i Priority Queue
        // PQ entry: {cost, node, switchUsedAtThisNode}
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));
        pq.offer(new long[]{0, 0, 0}); // {cost=0, node=0, switchUsed=0}

        while (!pq.isEmpty()) {
            long[] curr = pq.poll();
            long cost = curr[0];
            int node = (int) curr[1];
            int switchUsed = (int) curr[2];

            // Skip náº¿u Ä‘Ã£ tÃ¬m Ä‘Æ°á»£c Ä‘Æ°á»ng tá»‘t hÆ¡n
            if (cost > dist[node][switchUsed]) {
                continue;
            }

            // ÄÃ£ Ä‘áº¿n Ä‘Ã­ch!
            if (node == n - 1) {
                return (int) cost;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // OPTION A: Äi theo cáº¡nh ra bÃ¬nh thÆ°á»ng (u â†’ v)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            for (int[] edge : outEdges[node]) {
                int nextNode = edge[0];
                int weight = edge[1];
                long newCost = cost + weight;

                // Khi Ä‘áº¿n nextNode, switch cá»§a nextNode chÆ°a dÃ¹ng (= 0)
                if (newCost < dist[nextNode][0]) {
                    dist[nextNode][0] = newCost;
                    pq.offer(new long[]{newCost, nextNode, 0});
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // OPTION B: DÃ¹ng switch Ä‘á»ƒ Ä‘áº£o incoming edge (náº¿u chÆ°a dÃ¹ng)
            // Cáº¡nh v â†’ node Ä‘áº£o thÃ nh node â†’ v, chi phÃ­ 2 * w
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (switchUsed == 0) {
                for (int[] inEdge : inEdges[node]) {
                    int vNode = inEdge[0];  // v lÃ  nguá»“n gá»‘c cá»§a cáº¡nh Ä‘áº¿n node
                    int weight = inEdge[1];
                    long newCost = cost + 2L * weight;

                    // Sau khi Ä‘áº£o, ta Ä‘áº¿n vNode, switch cá»§a vNode chÆ°a dÃ¹ng
                    // NhÆ°ng switch cá»§a node hiá»‡n táº¡i ÄÃƒ DÃ™NG
                    // Ta khÃ´ng cáº§n track switch Ä‘Ã£ dÃ¹ng á»Ÿ node cÅ© vÃ¬ ta Ä‘Ã£ rá»i Ä‘i
                    if (newCost < dist[vNode][0]) {
                        dist[vNode][0] = newCost;
                        pq.offer(new long[]{newCost, vNode, 0});
                    }
                }
            }
        }

        // KhÃ´ng tÃ¬m tháº¥y Ä‘Æ°á»ng Ä‘i
        return -1;
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * SOLUTION 2: Dijkstra vá»›i Graph biáº¿n Ä‘á»•i (Alternative Approach)
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * Ã TÆ¯á»NG:
     * Thay vÃ¬ track state, ta cÃ³ thá»ƒ biáº¿n Ä‘á»•i graph:
     * - Má»—i cáº¡nh u â†’ v vá»›i weight w â†’ thÃªm cáº¡nh v â†’ u vá»›i weight 2w
     * - NhÆ°ng pháº£i Ä‘áº£m báº£o má»—i node chá»‰ dÃ¹ng 1 cáº¡nh Ä‘áº£o ngÆ°á»£c
     *
     * Æ¯U ÄIá»‚M:
     * âœ“ ÄÆ¡n giáº£n hÃ³a logic
     *
     * NHÆ¯á»¢C ÄIá»‚M:
     * âœ— Cáº§n xá»­ lÃ½ constraint "chá»‰ dÃ¹ng 1 láº§n" phá»©c táº¡p hÆ¡n
     * âœ— KhÃ´ng phÃ¹ há»£p báº±ng Solution 1 cho bÃ i nÃ y
     *
     * GHI CHÃš: Solution nÃ y phá»©c táº¡p hÆ¡n vá»›i constraint 1 switch/node
     * nÃªn Solution 1 Ä‘Æ°á»£c recommend hÆ¡n.
     */
    public int minimumCostAlternative(int n, int[][] edges) {
        // TÆ°Æ¡ng tá»± Solution 1 nhÆ°ng tracking khÃ¡c
        // Äá»ƒ Ä‘Æ¡n giáº£n, ta dÃ¹ng Solution 1
        return minimumCost(n, edges);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST CASES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    public static void main(String[] args) {
        MinCostPathWithEdgeReversals solution = new MinCostPathWithEdgeReversals();

        // Test 1: ÄÆ°á»ng tháº³ng Ä‘Æ¡n giáº£n
        // 0 â†’ 1 â†’ 2
        int[][] edges1 = {{0, 1, 3}, {1, 2, 4}};
        System.out.println("Test 1: " + solution.minimumCost(3, edges1));
        // Expected: 7 (Ä‘i tháº³ng 0â†’1â†’2)

        // Test 2: Cáº§n Ä‘áº£o ngÆ°á»£c
        // 0 â† 1, 1 â†’ 2  (khÃ´ng cÃ³ Ä‘Æ°á»ng tá»« 0)
        // Äáº£o ngÆ°á»£c 1â†’0 thÃ nh 0â†’1
        int[][] edges2 = {{1, 0, 5}, {1, 2, 3}};
        System.out.println("Test 2: " + solution.minimumCost(3, edges2));
        // Expected: 10 + 3 = 13 (Ä‘áº£o ngÆ°á»£c 1â†’0 rá»“i Ä‘i 1â†’2)

        // Test 3: KhÃ´ng cÃ³ Ä‘Æ°á»ng Ä‘i
        int[][] edges3 = {{1, 2, 1}};
        System.out.println("Test 3: " + solution.minimumCost(3, edges3));
        // Expected: -1

        // Test 4: CÃ³ nhiá»u lá»±a chá»n
        int[][] edges4 = {{0, 1, 1}, {2, 0, 2}, {1, 2, 3}};
        System.out.println("Test 4: " + solution.minimumCost(3, edges4));
        // 0â†’1â†’2 = 1+3 = 4
        // 0 (reverse 2â†’0) â†’ 2 = 2*2 = 4
        // Expected: 4
    }
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Tá»”NG Káº¾T & Máº¸O NHá»š
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ ğŸ“Œ PATTERN RECOGNITION                                                      â”‚
 * â”‚                                                                             â”‚
 * â”‚ Khi tháº¥y:                                                                   â”‚
 * â”‚ â€¢ "DÃ¹ng Ä‘Æ°á»£c K láº§n"        â†’ State thÃªm dimension                           â”‚
 * â”‚ â€¢ "Má»—i node cÃ³ kháº£ nÄƒng X" â†’ dist[node][usedX]                              â”‚
 * â”‚ â€¢ "Äáº£o ngÆ°á»£c cáº¡nh"         â†’ Track cáº£ inEdges                               â”‚
 * â”‚                                                                             â”‚
 * â”‚ CÃ´ng thá»©c: DIJKSTRA + STATE = BÃ i graph cÃ³ constraint Ä‘áº·c biá»‡t              â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ ğŸ¯ CHECKLIST GIáº¢I BÃ€I                                                       â”‚
 * â”‚                                                                             â”‚
 * â”‚ 1. â–¡ XÃ¡c Ä‘á»‹nh: Weighted graph â†’ Dijkstra (khÃ´ng pháº£i BFS)                   â”‚
 * â”‚ 2. â–¡ CÃ³ constraint Ä‘áº·c biá»‡t â†’ ThÃªm state vÃ o dist                           â”‚
 * â”‚ 3. â–¡ Build Ä‘á»§ adjacency lists cáº§n thiáº¿t                                     â”‚
 * â”‚ 4. â–¡ PQ entry chá»©a Ä‘á»§ thÃ´ng tin: (cost, node, states...)                    â”‚
 * â”‚ 5. â–¡ Xá»­ lÃ½ táº¥t cáº£ transitions tá»« node hiá»‡n táº¡i                              â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ ğŸ’¡ SIMILAR PROBLEMS                                                         â”‚
 * â”‚                                                                             â”‚
 * â”‚ â€¢ 787. Cheapest Flights Within K Stops                                      â”‚
 * â”‚ â€¢ 1293. Shortest Path in Grid with Obstacles Elimination                    â”‚
 * â”‚ â€¢ 1368. Minimum Cost to Make at Least One Valid Path                        â”‚
 * â”‚ â€¢ 882. Reachable Nodes In Subdivided Graph                                  â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */
