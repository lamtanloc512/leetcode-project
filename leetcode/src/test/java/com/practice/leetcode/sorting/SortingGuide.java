package com.practice.leetcode.sorting;

import org.junit.jupiter.api.Test;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                                   SORTING ALGORITHMS GUIDE                                       â•‘
 * â•‘                              HÆ°á»›ng dáº«n cÃ¡c thuáº­t toÃ¡n sáº¯p xáº¿p                                    â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”
 * â”‚                                    Báº¢NG TÃ“M Táº®T THUáº¬T TOÃN                                        â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚   Thuáº­t toÃ¡n    â”‚   Best Case     â”‚   Worst Case    â”‚     Space       â”‚   Äáº·c Ä‘iá»ƒm ná»•i báº­t        â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ Bubble Sort     â”‚     O(N)        â”‚     O(NÂ²)       â”‚     O(1)        â”‚ Dá»… hiá»ƒu nháº¥t              â”‚
 * â”‚ Selection Sort  â”‚     O(NÂ²)       â”‚     O(NÂ²)       â”‚     O(1)        â”‚ Ãt swap nháº¥t              â”‚
 * â”‚ Insertion Sort  â”‚     O(N)        â”‚     O(NÂ²)       â”‚     O(1)        â”‚ Tá»‘t cho máº£ng gáº§n nhÆ° Ä‘Ã£   â”‚
 * â”‚                 â”‚                 â”‚                 â”‚                 â”‚ sáº¯p xáº¿p                   â”‚
 * â”‚ Merge Sort      â”‚     O(N log N)  â”‚     O(N log N)  â”‚     O(N)        â”‚ Stable, tá»‘t nháº¥t cho      â”‚
 * â”‚                 â”‚                 â”‚                 â”‚                 â”‚ dá»¯ liá»‡u lá»›n               â”‚
 * â”‚ Quick Sort      â”‚     O(N log N)  â”‚     O(NÂ²)       â”‚   O(log N)      â”‚ Nhanh trong thá»±c táº¿       â”‚
 * â”‚ Heap Sort       â”‚     O(N log N)  â”‚     O(N log N)  â”‚     O(1)        â”‚ In-place, khÃ´ng stable    â”‚
 * â”‚ Counting Sort   â”‚     O(N + K)    â”‚     O(N + K)    â”‚     O(K)        â”‚ Tá»‘t cho sá»‘ nguyÃªn nhá»     â”‚
 * â”‚ Radix Sort      â”‚     O(N * D)    â”‚     O(N * D)    â”‚     O(N + K)    â”‚ Tá»‘t cho sá»‘ nguyÃªn lá»›n     â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 * 
 * â–¶ STABLE SORT: Giá»¯ nguyÃªn thá»© tá»± tÆ°Æ¡ng Ä‘á»‘i cá»§a cÃ¡c pháº§n tá»­ báº±ng nhau
 * â–¶ IN-PLACE: KhÃ´ng cáº§n thÃªm bá»™ nhá»› phá»¥ Ä‘Ã¡ng ká»ƒ
 */
public class SortingGuide {

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                      1. BUBBLE SORT
    //                                     (Sáº¯p xáº¿p ná»•i bá»t)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ:                                                                                  â”‚
     * â”‚ â€¢ So sÃ¡nh tá»«ng cáº·p pháº§n tá»­ liá»n ká»                                                          â”‚
     * â”‚ â€¢ Náº¿u sai thá»© tá»± â†’ swap                                                                     â”‚
     * â”‚ â€¢ Pháº§n tá»­ lá»›n nháº¥t "ná»•i" lÃªn cuá»‘i sau má»—i lÆ°á»£t                                              â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [5, 3, 8, 1]                                                                      â”‚
     * â”‚ LÆ°á»£t 1: [3, 5, 1, 8] â†’ 8 ná»•i lÃªn cuá»‘i                                                       â”‚
     * â”‚ LÆ°á»£t 2: [3, 1, 5, 8] â†’ 5 ná»•i lÃªn                                                            â”‚
     * â”‚ LÆ°á»£t 3: [1, 3, 5, 8] â†’ Xong!                                                                â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(NÂ²) thá»i gian, O(1) khÃ´ng gian                                               â”‚
     * â”‚ âš ï¸ KHÃ”NG DÃ™NG trong thá»±c táº¿ (chá»‰ Ä‘á»ƒ há»c)                                                    â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int[] bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false; // Tá»‘i Æ°u: dá»«ng sá»›m náº¿u khÃ´ng cÃ³ swap
            
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            
            // Náº¿u khÃ´ng cÃ³ swap nÃ o â†’ máº£ng Ä‘Ã£ sáº¯p xáº¿p
            if (!swapped) break;
        }
        return arr;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                    2. SELECTION SORT
    //                                    (Sáº¯p xáº¿p chá»n lá»c)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ:                                                                                  â”‚
     * â”‚ â€¢ TÃ¬m pháº§n tá»­ nhá» nháº¥t trong pháº§n chÆ°a sáº¯p xáº¿p                                              â”‚
     * â”‚ â€¢ Swap nÃ³ vá»›i pháº§n tá»­ Ä‘áº§u tiÃªn cá»§a pháº§n chÆ°a sáº¯p xáº¿p                                        â”‚
     * â”‚ â€¢ Láº·p láº¡i cho Ä‘áº¿n háº¿t                                                                       â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [5, 3, 8, 1]                                                                      â”‚
     * â”‚ BÆ°á»›c 1: TÃ¬m min=1 â†’ swap vá»›i 5 â†’ [1, 3, 8, 5]                                               â”‚
     * â”‚ BÆ°á»›c 2: TÃ¬m min=3 (Ä‘Ã£ Ä‘Ãºng vá»‹ trÃ­) â†’ [1, 3, 8, 5]                                           â”‚
     * â”‚ BÆ°á»›c 3: TÃ¬m min=5 â†’ swap vá»›i 8 â†’ [1, 3, 5, 8]                                               â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Æ¯U ÄIá»‚M: Sá»‘ láº§n swap Ã­t nháº¥t (chá»‰ N-1 láº§n)                                                  â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(NÂ²) thá»i gian, O(1) khÃ´ng gian                                               â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int[] selectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            
            // TÃ¬m pháº§n tá»­ nhá» nháº¥t trong pháº§n cÃ²n láº¡i
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            // Swap náº¿u tÃ¬m Ä‘Æ°á»£c pháº§n tá»­ nhá» hÆ¡n
            if (minIdx != i) {
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
        return arr;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                    3. INSERTION SORT
    //                                    (Sáº¯p xáº¿p chÃ¨n)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ: (Giá»‘ng cÃ¡ch xáº¿p bÃ i trong tay)                                                   â”‚
     * â”‚ â€¢ Láº¥y tá»«ng pháº§n tá»­ tá»« pháº§n chÆ°a sáº¯p xáº¿p                                                     â”‚
     * â”‚ â€¢ ChÃ¨n vÃ o Ä‘Ãºng vá»‹ trÃ­ trong pháº§n Ä‘Ã£ sáº¯p xáº¿p                                                â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [5, 3, 8, 1]                                                                      â”‚
     * â”‚ BÆ°á»›c 1: Láº¥y 3, chÃ¨n trÆ°á»›c 5 â†’ [3, 5, 8, 1]                                                  â”‚
     * â”‚ BÆ°á»›c 2: Láº¥y 8, giá»¯ nguyÃªn â†’ [3, 5, 8, 1]                                                    â”‚
     * â”‚ BÆ°á»›c 3: Láº¥y 1, chÃ¨n Ä‘áº§u â†’ [1, 3, 5, 8]                                                      â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Æ¯U ÄIá»‚M: Ráº¥t nhanh vá»›i máº£ng gáº§n nhÆ° Ä‘Ã£ sáº¯p xáº¿p â†’ O(N)                                       â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(NÂ²) worst case, O(1) khÃ´ng gian                                              â”‚
     * â”‚ ğŸ’¡ DÃ¹ng tá»‘t khi: Dá»¯ liá»‡u nhá» hoáº·c gáº§n nhÆ° Ä‘Ã£ sorted                                         â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int[] insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];            // Pháº§n tá»­ cáº§n chÃ¨n
            int j = i - 1;
            
            // Dá»‹ch cÃ¡c pháº§n tá»­ lá»›n hÆ¡n key sang pháº£i
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            // ChÃ¨n key vÃ o Ä‘Ãºng vá»‹ trÃ­
            arr[j + 1] = key;
        }
        return arr;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                      4. MERGE SORT
    //                                   (Sáº¯p xáº¿p trá»™n - Chia Ä‘á»ƒ trá»‹)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ: DIVIDE AND CONQUER (Chia Ä‘á»ƒ trá»‹)                                                 â”‚
     * â”‚ 1. DIVIDE: Chia máº£ng thÃ nh 2 ná»­a                                                            â”‚
     * â”‚ 2. CONQUER: Äá»‡ quy sáº¯p xáº¿p tá»«ng ná»­a                                                         â”‚
     * â”‚ 3. COMBINE: Trá»™n 2 ná»­a Ä‘Ã£ sáº¯p xáº¿p thÃ nh máº£ng hoÃ n chá»‰nh                                     â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [5, 3, 8, 1]                                                                      â”‚
     * â”‚                   [5,3,8,1]                                                                 â”‚
     * â”‚                  /        \                                                                 â”‚
     * â”‚               [5,3]      [8,1]         â† DIVIDE                                             â”‚
     * â”‚               /   \      /   \                                                              â”‚
     * â”‚             [5]  [3]   [8]  [1]        â† CONQUER (base case)                                â”‚
     * â”‚               \   /      \   /                                                              â”‚
     * â”‚               [3,5]      [1,8]         â† MERGE                                              â”‚
     * â”‚                  \        /                                                                 â”‚
     * â”‚                  [1,3,5,8]             â† MERGE final                                        â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N log N) thá»i gian, O(N) khÃ´ng gian                                          â”‚
     * â”‚ â­ STABLE SORT: Giá»¯ thá»© tá»± cÃ¡c pháº§n tá»­ báº±ng nhau                                            â”‚
     * â”‚ ğŸ’¡ DÃ¹ng khi: Cáº§n stable sort, dá»¯ liá»‡u lá»›n                                                   â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int[] mergeSort(int[] arr) {
        if (arr.length <= 1) return arr;
        
        int mid = arr.length / 2;
        
        // Chia máº£ng thÃ nh 2 ná»­a
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        
        // Äá»‡ quy sáº¯p xáº¿p tá»«ng ná»­a
        left = mergeSort(left);
        right = mergeSort(right);
        
        // Trá»™n 2 máº£ng Ä‘Ã£ sáº¯p xáº¿p
        return merge(left, right);
    }
    
    private int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        
        // So sÃ¡nh tá»«ng pháº§n tá»­ vÃ  thÃªm vÃ o káº¿t quáº£
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {  // <= Ä‘á»ƒ giá»¯ stable
            result[k++] = left[i++];
            } else {
            result[k++] = right[j++];
            }
        }
        
        // ThÃªm pháº§n cÃ²n láº¡i
        while (i < left.length) result[k++] = left[i++];
        while (j < right.length) result[k++] = right[j++];
        
        return result;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                      5. QUICK SORT
    //                                   (Sáº¯p xáº¿p nhanh - Chia Ä‘á»ƒ trá»‹)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ: DIVIDE AND CONQUER vá»›i PIVOT                                                     â”‚
     * â”‚ 1. Chá»n má»™t pháº§n tá»­ lÃ m PIVOT (thÆ°á»ng lÃ  cuá»‘i máº£ng)                                         â”‚
     * â”‚ 2. PARTITION: ÄÆ°a táº¥t cáº£ pháº§n tá»­ < pivot sang trÃ¡i, > pivot sang pháº£i                       â”‚
     * â”‚ 3. Äá»‡ quy sáº¯p xáº¿p 2 pháº§n                                                                    â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [5, 3, 8, 1, 4] vá»›i pivot = 4                                                     â”‚
     * â”‚ Partition: [3, 1, 4, 5, 8] â†’ 4 Ä‘Ã£ Ä‘Ãºng vá»‹ trÃ­                                               â”‚
     * â”‚ Äá»‡ quy: [3, 1] vÃ  [5, 8]                                                                    â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P:                                                                                â”‚
     * â”‚ â€¢ Average: O(N log N)                                                                       â”‚
     * â”‚ â€¢ Worst (Ä‘Ã£ sorted): O(NÂ²) - chá»n pivot xáº¥u                                                 â”‚
     * â”‚ â€¢ Space: O(log N) cho call stack                                                            â”‚
     * â”‚                                                                                             â”‚
     * â”‚ â­ NHANH NHáº¤T trong thá»±c táº¿ (cache-friendly)                                                â”‚
     * â”‚ âš ï¸ KHÃ”NG STABLE                                                                             â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            
            quickSort(arr, low, pivotIndex - 1);   // Sáº¯p xáº¿p bÃªn trÃ¡i pivot
            quickSort(arr, pivotIndex + 1, high);  // Sáº¯p xáº¿p bÃªn pháº£i pivot
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];  // Chá»n pháº§n tá»­ cuá»‘i lÃ m pivot
        int i = low - 1;        // Vá»‹ trÃ­ cuá»‘i cá»§a pháº§n < pivot
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                // Swap arr[i] vÃ  arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        // Äáº·t pivot vÃ o Ä‘Ãºng vá»‹ trÃ­
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                      6. HEAP SORT
    //                                    (Sáº¯p xáº¿p vun Ä‘á»‘ng)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ: Sá»­ dá»¥ng cáº¥u trÃºc dá»¯ liá»‡u HEAP                                                    â”‚
     * â”‚ 1. XÃ¢y dá»±ng MAX-HEAP tá»« máº£ng                                                                â”‚
     * â”‚ 2. Láº¥y pháº§n tá»­ lá»›n nháº¥t (root) Ä‘áº·t cuá»‘i máº£ng                                                â”‚
     * â”‚ 3. Giáº£m kÃ­ch thÆ°á»›c heap, heapify láº¡i                                                        â”‚
     * â”‚ 4. Láº·p láº¡i cho Ä‘áº¿n háº¿t                                                                      â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MAX-HEAP: Má»—i node cha >= cÃ¡c node con                                                      â”‚
     * â”‚        8                                                                                    â”‚
     * â”‚       / \                                                                                   â”‚
     * â”‚      5   6      â†’ Máº£ng: [8, 5, 6, 1, 3]                                                     â”‚
     * â”‚     / \                                                                                     â”‚
     * â”‚    1   3                                                                                    â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N log N) thá»i gian, O(1) khÃ´ng gian                                          â”‚
     * â”‚ â­ IN-PLACE: KhÃ´ng cáº§n bá»™ nhá»› phá»¥                                                           â”‚
     * â”‚ ğŸ’¡ DÃ¹ng khi: Cáº§n sáº¯p xáº¿p in-place vá»›i worst-case O(N log N)                                 â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public void heapSort(int[] arr) {
        int n = arr.length;
        
        // BÆ°á»›c 1: XÃ¢y dá»±ng max-heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // BÆ°á»›c 2: Láº¥y root vÃ  heapify
        for (int i = n - 1; i > 0; i--) {
            // ÄÆ°a root (lá»›n nháº¥t) vá» cuá»‘i
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            // Heapify láº¡i vá»›i heap nhá» hÆ¡n
            heapify(arr, i, 0);
        }
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            
            heapify(arr, n, largest);
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                    7. COUNTING SORT
    //                                    (Sáº¯p xáº¿p Ä‘áº¿m)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ: Äáº¿m sá»‘ láº§n xuáº¥t hiá»‡n cá»§a má»—i giÃ¡ trá»‹                                             â”‚
     * â”‚ 1. TÃ¬m min vÃ  max cá»§a máº£ng Ä‘á»ƒ xÃ¡c Ä‘á»‹nh pháº¡m vi (Range K)                                    â”‚
     * â”‚ 2. Táº¡o máº£ng Ä‘áº¿m count[] cÃ³ kÃ­ch thÆ°á»›c K                                                     â”‚
     * â”‚ 3. Duyá»‡t máº£ng gá»‘c, Ä‘áº¿m táº§n suáº¥t xuáº¥t hiá»‡n cá»§a tá»«ng sá»‘                                       â”‚
     * â”‚ 4. Cá»™ng dá»“n máº£ng Ä‘áº¿m (Prefix Sum) Ä‘á»ƒ xÃ¡c Ä‘á»‹nh vá»‹ trÃ­ cuá»‘i cÃ¹ng cá»§a má»—i pháº§n tá»­ (Stable)     â”‚
     * â”‚    HOáº¶C: Chá»‰ cáº§n duyá»‡t máº£ng Ä‘áº¿m vÃ  ghi láº¡i giÃ¡ trá»‹ náº¿u khÃ´ng cáº§n Stable                     â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [4, 2, 2, 8, 3, 3, 1] (Min=1, Max=8 â†’ K=8)                                        â”‚
     * â”‚ count: [0, 1, 2, 2, 1, 0, 0, 0, 1] (index map: 0â†’?, 1â†’1, 2â†’2...)                            â”‚
     * â”‚ result: [1, 2, 2, 3, 3, 4, 8]                                                               â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N + K) vá»›i K = max - min                                                     â”‚
     * â”‚ â­ NHANH NHáº¤T cho dÃ£y sá»‘ nguyÃªn cÃ³ pháº¡m vi nhá» (vÃ­ dá»¥: Ä‘iá»ƒm thi 0-10, tuá»•i 0-100)           â”‚
     * â”‚ âš ï¸ Tá»‘n bá»™ nhá»› náº¿u K quÃ¡ lá»›n (vÃ­ dá»¥: [1, 1000000] â†’ máº£ng count tá»›i 1 triá»‡u pháº§n tá»­)          â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public int[] countingSort(int[] arr) {
        if (arr.length == 0) return arr;
        
        // TÃ¬m min vÃ  max
        int min = arr[0], max = arr[0];
        for (int num : arr) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        
        // Táº¡o máº£ng Ä‘áº¿m
        int range = max - min + 1;
        int[] count = new int[range];
        
        // Äáº¿m sá»‘ láº§n xuáº¥t hiá»‡n
        for (int num : arr) {
            count[num - min]++;
        }
        
        // TÃ¡i táº¡o máº£ng
        int[] result = new int[arr.length];
        int index = 0;
        for (int i = 0; i < range; i++) {
            while (count[i] > 0) {
                result[index++] = i + min;
                count[i]--;
            }
        }
        
        return result;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                    8. RADIX SORT
    //                                    (Sáº¯p xáº¿p cÆ¡ sá»‘)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ NGUYÃŠN LÃ: Sáº¯p xáº¿p dá»±a trÃªn tá»«ng chá»¯ sá»‘ (hoáº·c bit)                                          â”‚
     * â”‚ 1. Sáº¯p xáº¿p cÃ¡c sá»‘ theo chá»¯ sá»‘ hÃ ng Ä‘Æ¡n vá»‹ (dÃ¹ng Counting Sort á»•n Ä‘á»‹nh)                      â”‚
     * â”‚ 2. Tiáº¿p tá»¥c sáº¯p xáº¿p theo hÃ ng chá»¥c, hÃ ng trÄƒm...                                            â”‚
     * â”‚ 3. Sau khi sáº¯p xáº¿p Ä‘áº¿n chá»¯ sá»‘ lá»›n nháº¥t, máº£ng sáº½ Ä‘Æ°á»£c sáº¯p xáº¿p hoÃ n toÃ n                      â”‚
     * â”‚                                                                                             â”‚
     * â”‚ MINH Há»ŒA: [170, 45, 75, 90, 802, 24, 2, 66]                                                 â”‚
     * â”‚ HÃ ng Ä‘Æ¡n vá»‹: [170, 90, 802, 2, 24, 45, 75, 66] (sort theo 0,0,2,2,4,5,5,6)                  â”‚
     * â”‚ HÃ ng chá»¥c:   [802, 2, 24, 45, 66, 170, 75, 90] (0,0,2,4,6,7,7,9)                            â”‚
     * â”‚ HÃ ng trÄƒm:   [2, 24, 45, 66, 75, 90, 170, 802] (0,0,0,0,0,0,1,8) â†’ Xong!                    â”‚
     * â”‚                                                                                             â”‚
     * â”‚ Äá»˜ PHá»¨C Táº P: O(N * D) vá»›i D lÃ  sá»‘ lÆ°á»£ng chá»¯ sá»‘ cá»§a sá»‘ lá»›n nháº¥t                              â”‚
     * â”‚ â­ Cá»±c nhanh khi D nhá» (vÃ­ dá»¥ sá»‘ < 1 tá»· chá»‰ cÃ³ 9 chá»¯ sá»‘ â†’ D=9)                              â”‚
     * â”‚ ğŸ’¡ Ãp dá»¥ng tá»‘t cho sá»‘ nguyÃªn, chuá»—i kÃ½ tá»± Ä‘á»™ dÃ i cá»‘ Ä‘á»‹nh                                    â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */
    public void radixSort(int[] arr) {
        if (arr.length == 0) return;

        // TÃ¬m sá»‘ lá»›n nháº¥t Ä‘á»ƒ biáº¿t sá»‘ chá»¯ sá»‘ (D)
        int max = Arrays.stream(arr).max().getAsInt();

        // Thá»±c hiá»‡n counting sort cho tá»«ng hÃ ng Ä‘Æ¡n vá»‹ (exp = 1, 10, 100...)
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countSortForRadix(arr, exp);
        }
    }

    private void countSortForRadix(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10]; // Há»‡ tháº­p phÃ¢n (0-9)

        // Äáº¿m sá»‘ láº§n xuáº¥t hiá»‡n táº¡i hÃ ng Ä‘ang xÃ©t
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % 10;
            count[digit]++;
        }

        // Cá»™ng dá»“n count Ä‘á»ƒ xÃ¡c Ä‘á»‹nh vá»‹ trÃ­
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        // XÃ¢y dá»±ng máº£ng output (Ä‘i ngÆ°á»£c Ä‘á»ƒ giá»¯ stable)
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }

        // Copy láº¡i vÃ o máº£ng gá»‘c
        System.arraycopy(output, 0, arr, 0, n);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                    Máº¸O PHá»NG Váº¤N
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    /**
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚                              ğŸ¯ Lá»°A CHá»ŒN THUáº¬T TOÃN ÄÃšNG                                    â”‚
     * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     * â”‚                                                                                             â”‚
     * â”‚ 1. Trong thá»±c táº¿: DÃ¹ng Arrays.sort() hoáº·c Collections.sort()                                â”‚
     * â”‚    â†’ Java dÃ¹ng Dual-Pivot QuickSort cho primitive, TimSort cho Object                       â”‚
     * â”‚                                                                                             â”‚
     * â”‚ 2. Cáº§n STABLE sort?                                                                         â”‚
     * â”‚    â†’ Merge Sort hoáº·c built-in sort                                                          â”‚
     * â”‚                                                                                             â”‚
     * â”‚ 3. Dá»¯ liá»‡u nhá» (N < 50)?                                                                    â”‚
     * â”‚    â†’ Insertion Sort (overhead tháº¥p)                                                         â”‚
     * â”‚                                                                                             â”‚
     * â”‚ 4. GiÃ¡ trá»‹ trong range nhá» (0-100, 0-1000)?                                                 â”‚
     * â”‚    â†’ Counting Sort                                                                          â”‚
     * â”‚                                                                                             â”‚
     * â”‚ 5. Cáº§n tÃ¬m K pháº§n tá»­ lá»›n/nhá» nháº¥t?                                                          â”‚
     * â”‚    â†’ Quick Select (O(N) average) hoáº·c Heap (O(N log K))                                     â”‚
     * â”‚                                                                                             â”‚
     * â”‚ 6. Phá»ng váº¥n há»i implement sorting?                                                         â”‚
     * â”‚    â†’ Merge Sort (dá»… viáº¿t Ä‘Ãºng, stable, O(N log N) guaranteed)                               â”‚
     * â”‚    â†’ Quick Sort (náº¿u interviewer yÃªu cáº§u in-place)                                          â”‚
     * â”‚                                                                                             â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     */


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //                                         TESTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    @Test
    void testBubbleSort() {
        assertArrayEquals(new int[]{1, 3, 5, 8}, bubbleSort(new int[]{5, 3, 8, 1}));
        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, bubbleSort(new int[]{5, 4, 3, 2, 1}));
    }
    
    @Test
    void testSelectionSort() {
        assertArrayEquals(new int[]{1, 3, 5, 8}, selectionSort(new int[]{5, 3, 8, 1}));
    }
    
    @Test
    void testInsertionSort() {
        assertArrayEquals(new int[]{1, 3, 5, 8}, insertionSort(new int[]{5, 3, 8, 1}));
    }
    
    @Test
    void testMergeSort() {
        assertArrayEquals(new int[]{1, 3, 5, 8}, mergeSort(new int[]{5, 3, 8, 1}));
        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6}, mergeSort(new int[]{6, 5, 4, 3, 2, 1}));
    }
    
    @Test
    void testQuickSort() {
        int[] arr = {5, 3, 8, 1, 4};
        quickSort(arr, 0, arr.length - 1);
        assertArrayEquals(new int[]{1, 3, 4, 5, 8}, arr);
    }
    
    @Test
    void testHeapSort() {
        int[] arr = {5, 3, 8, 1, 4};
        heapSort(arr);
        assertArrayEquals(new int[]{1, 3, 4, 5, 8}, arr);
    }
    
    @Test
    void testCountingSort() {
        assertArrayEquals(new int[]{1, 2, 2, 3, 3, 4, 8}, countingSort(new int[]{4, 2, 2, 8, 3, 3, 1}));
    }

    @Test
    void testRadixSort() {
        int[] arr = { 170, 45, 75, 90, 802, 24, 2, 66 };
        radixSort(arr);
        assertArrayEquals(new int[] { 2, 24, 45, 66, 75, 90, 170, 802 }, arr);
    }
}
